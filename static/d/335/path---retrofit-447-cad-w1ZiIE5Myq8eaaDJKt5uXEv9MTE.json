{"data":{"site":{"siteMetadata":{"title":"Burkay Durdu Blog","author":"Burkay Durdu"}},"markdownRemark":{"id":"39788e18-b98a-591e-9666-6c654c4b8fe1","excerpt":"GET  Get methodu ile genellikle server'dan bilgi talebinde bulunuldugu zaman kullanilir. @Path  Path ile url kisminda dinamik olarak değiştirebildiğimiz aralığa…","html":"<h2>GET</h2>\n<p> Get methodu ile genellikle server'dan bilgi talebinde bulunuldugu zaman kullanilir.</p>\n<h4>@Path</h4>\n<pre><code class=\"language-java\">@GET(\"users/{name}/commit\")\nCall&#x3C;List&#x3C;Commit>> getCommitsByName(@Path(\"name\") String name)\n</code></pre>\n<p> Path ile url kisminda dinamik olarak değiştirebildiğimiz aralığa değerleri girmemizi sağlıyor. Bu aralık formatı <code>/{değişken}/</code> şeklinde olup alt satırda görülen bu methodu fonksiyon haline getiren Call ile başlayan yerde url kısmındaki değişkenlerin adini verip değer ataması yapmamızı sağlıyor.</p>\n<h4>@Query</h4>\n<pre><code class=\"language-java\">@GET(\"users\")\nCall&#x3C;User> getUserById(@Query(\"id\") Integer id)\n</code></pre>\n<p> Query url kısmında  <strong>../path?</strong> yada <strong>.com?</strong> yazıldıktan sonra <code>name=burkay&#x26;password=1234</code>seklinde veriler <em>key=value</em> formatında olup birden fazla veri arasına <strong>&#x26;</strong> karakteri geliyor.</p>\n<h2>POST</h2>\n<p>  Post metodu ile genellikle kayıt gibi işlemler yapılır. Form yapısında olan veriler server tarafına aktarılır.</p>\n<h4>@Field</h4>\n<pre><code class=\"language-java\">@FormUrlEncoded\n@POST(\"/api/register\")\nCall&#x3C;ResponseBody> registerRequest(@Field(\"username\") String username,\n                                   @Field(\"name\") String name,\n                                   @Field(\"surname\") String surname,\n                                   @Field(\"password\") String password,\n                                   @Field(\"email\") String email);\n</code></pre>\n<p>Burada post metodunu etkinlestiriyoruz. Sunucu tarafinda body icinde alinacak keyler field icerigine giriliyor. Bu bilgileri request olusturdugumuz yerde veriyoruz. Burada önemli faktörlerden birisi <code>@FormUrlEncoded</code> Bu belirteç bize giden formatın bir form şeklinde olacağını söylüyor. Body sinde belirtilen değerler <em>key:value</em> şeklinde object formatındadır.</p>\n<h2>PUT</h2>\n<p>Put metodu genellikle güncelleme yaparken kullanılan bir http metodudur.****\nPut, <code>Post</code> gibi field key word ile birlikte body data kısmına veriler gönderebilirsiniz. Bir diğer özelliği ise  <code>get</code> kullanılan path yani url uzerlinde erişim anahtarı üzerinden  veri gönderimi yapılabilir.</p>\n<pre><code class=\"language-java\">@FormUrlEncoded\n@PUT(\"/api/user/update/\")\nCall&#x3C;General> userUpdate(\n         @Field(\"user_id\") String userId,\n         @Field(\"name\") String name);\n</code></pre>\n<pre><code class=\"language-java\">@PUT(\"gists/{id}\")\nCall&#x3C;ResponseBody> updateGist(\n    @Path(\"id\") String id,\n    @Body Gist gist);\n</code></pre>\n<p>Burada <code>@Body</code> olarak yazilan yapi bir class nesnesi gönderirsiniz ve o bu nesneyi çözümleyerek ilgili key-value dönüşümü yaparak veriyi iletir.</p>\n<h2>DELETE</h2>\n<p>Delete metodu genelde veri silinmesinde  yada değiştirilmesinde kullanılan bir yapıdır. Aslında bu yapıların yaptığı işlevi Post ve Get ile hepsini gerçekleştirebiliriz. Burada kullanılan yapılar okunurluk ve düzen olarak kurulan ve kendilerine belli durumlarda yetenkler kazandırılan yapılardır. Delete nin kullanımı ile örnek verirsek.</p>\n<pre><code class=\"language-java\">@DELETE('/delete/book')\nCall&#x3C;ResponseBody> deleteBook(\n     @Path(\"id\") int bookId);\n</code></pre>\n<p>Görüldüğü üzerine get metodunda kullanılan path yapısı, yani url üzerinden veri aktarımını sağlayan yapı ile burada bu yapının özelliğini aktardığını görmüş olduk.</p>\n<h2>EK YAPILAR</h2>\n<h3>QueryMap</h3>\n<pre><code class=\"language-java\">@GET(\"/friends\")\nCall&#x3C;ResponseBody> friends(\n   @QueryMap Map&#x3C;String, String> filters);\n</code></pre>\n<blockquote>\n<p>Calling with foo.friends(ImmutableMap.of(\"group\", \"coworker\", \"age\", \"42\")) yields /friends?group=coworker&#x26;age=42.</p>\n</blockquote>\n<p>Bu query map ile java tarafından query kodunu hash map fonksiyonu ile setleyip yollayabilmemize yarıyor.</p>\n<pre><code class=\"language-java\">@GET(\"/news\")\nCall&#x3C;List&#x3C;News>> getNews(\n        @Query(\"page\") int page,\n        @Query(\"order\") String order,\n        @Query(\"author\") String author,\n        @Query(\"published_at\") Date date,\n        …\n);\n</code></pre>\n<p>Bu şekilde tek tek girmek herine yukarıda ki yapıyı kullanabiliriz veriyi gönderirken</p>\n<pre><code class=\"language-java\">Map&#x3C;String, String> data = new HashMap&#x3C;>();\n   data.put(\"author\", \"Marcus\");\n   data.put(\"page\", String.valueOf(2));\n</code></pre>\n<p>HashMap bu şekilde setleyip gönderebiliriz.</p>\n<h3>FieldMap</h3>\n<pre><code class=\"language-java\">@FormUrlEncoded\n@PUT(\"user\")\nCall&#x3C;User> update(\n  @FieldMap Map&#x3C;String, String> fields);\n</code></pre>\n<p>Görüldüğü gibi post veya put yapılarında kullanılan field nesnesi body içinde key : value olarak yapıları setler. Bu şekilde tek tek girmek yerine Bu verileri Map haline getiririz. QueryMap yaptığımız gibi HashMap fonksiyonu ile setler nesnesini yapıya göndeririz.</p>\n<pre><code class=\"language-java\">@FormUrlEncoded\n@PUT(\"user\")\nCall&#x3C;User> update(\n         @Field(\"username\") String username,\n         @Field(\"name\") String name,\n         @Field(\"email\") String email,\n         @Field(\"homepage\") String homepage,\n         @Field(\"location\") String location\n);\n</code></pre>\n<p>Bu şekilde göndermek yerine yukarıdaki gibi gönderebiliyoruz.</p>\n<h3>Headers</h3>\n<pre><code class=\"language-java\">@Headers({\n     \"Accept: application/vnd.yourapi.v1.full+json\",\n     \"User-Agent: Your-App-Name\"\n})\n@GET(\"/tasks/{task_id}\")\nTask getTask(@Path(\"task_id\") long taskId);\n</code></pre>\n<p>Headerlar gönderilen verileri betimleyen anlaşılması sağlayan başlık bilgileridir. Burada gönderilen dosyanın formatı, dil ayarları ve birçok bilgi burada setlenerek gönderilir karşı taraf ise bu dosyayı alınca önce header'ı okur.</p>\n<p>Header dinamik olarak güncellenebilir. Burada aşağıdaki örneği inceleyelim.</p>\n<pre><code class=\"language-java\">@GET(\"/tasks\")\n Call&#x3C;List&#x3C;Task>> getTasks(\n   @Header(\"Content-Range\") String contentRange);\n</code></pre>\n<h3>HeaderMap</h3>\n<pre><code class=\"language-java\">@GET(\"/tasks\")\nCall&#x3C;List&#x3C;Task>> getTasks(\n      @HeaderMap Map&#x3C;String, String> headers\n);\n</code></pre>\n<p>FieldMap yada QueryMap gibi çokca içerik varsa hashmap fonksiyonu ile daha toplu ve hızlı sonuca oluşmamızı sağlıyor.</p>\n<h3>FormUrlEncoded</h3>\n<pre><code class=\"language-java\">@FormUrlEncoded\n@POST(\"/api/user/reset/password\")...\n</code></pre>\n<p>Post veya Put gibi metotları formUrl formatına dönüştürüp gönderilmesini sağlayan yapıdır.</p>\n<h3>Retrofit Buildir Ve Çalıştırılması</h3>\n<p>Gerekli Metotlar tanımlanıp kullanılması tarafına geçilince öncelikle Retrofit nesnesini oluşturulması gereklidir.</p>\n<pre><code class=\"language-java\">private ApiAutService service;\n...\nprivate void onCreateService() {\n       Retrofit loginApi = new Retrofit.Builder()\n               .baseUrl(Service.BASE_URL)\n               .addConverterFactory(GsonConverterFactory.create())\n               .build();\n       service = loginApi.create(ApiAutService.class);\n}\n</code></pre>\n<p>Yukarıda oluşturulan yapı. Retrofit nesnesi oluşturuyoruz. Başlangıç url adresini veriyoruz. Daha sonra <code>GsonConverterFactory</code> ile metotlarda kullanılan yapılarda gson ile json gelen formatlar class lara dönüştürülmesini sağlıyor. Daha sonra bu oluşturulan retrofit nesnesi ile birlikte ilgili interface objesi setleniyor. Elimizde artık yazdığımız metotları kullanabildiğimiz bir nesne bulunuyor.</p>\n<pre><code class=\"language-java\">Call&#x3C;LoginData> loginSocialRequest = service.loginSocialRequest(id, platform.toString());\n    loginSocialRequest.enqueue(new retrofit2.Callback&#x3C;LoginData>() {\n        @Override\n        public void onResponse(@NonNull Call&#x3C;LoginData> call, @NonNull Response&#x3C;LoginData> response) {\n            if (response.body() != null) {\n                if (response.body().getSuccess()) {\n                    ..\n                } else {\n                    ..\n                }\n            } else { message(R.string.server_response_error, true); }\n        }\n        @Override\n        public void onFailure(@NonNull Call&#x3C;LoginData> call, @NonNull Throwable t) {\n            message(R.string.server_response_error, true);\n            Log.e(\"Serve error\", t.getMessage());\n       }\n});\n</code></pre>\n<p>Yukarıda görüldüğü üzere yazılan metotları çağırıp asenkron çalışan callback metodu oluşturulur. Daha sonra verilen objeye göre gson dönüşümü yapılır, daha sonra veriler gerekli class formatına dönüştürülünce  <code>response</code> parametresinde bulunan <code>response.body()</code> içinde gerekli class nesnesi görülür. Bir çok yapıda kullandığımız için gelen veri tek bir tane değilde liste şeklinde geliyorsa. Metot oluşturulurken <code>Call&#x3C;List&#x3C;ObjeClass>></code> diye verilerek gelen veri bir liste şeklinde olur. Daha sonra bu liste yukarıdaki yapı ile alınarak gerekli <strong>ArrayList</strong> nesnesine setlenerek kullanılabilir.</p>","frontmatter":{"title":"Retrofit","date":"May 15, 2017"}}},"pageContext":{"slug":"/retrofit/","previous":null,"next":{"fields":{"slug":"/clojure/"},"frontmatter":{"title":"Clojure"}}}}